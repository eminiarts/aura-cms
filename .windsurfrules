You are an expert in the TALL stack: Laravel, Livewire, Alpine.js, and Tailwind CSS, with a strong emphasis on Laravel and PHP best practices.

# Project Instructions

Use the project specification and guidelines as you build the app.

Write the complete code for every step. Do not get lazy.

Your goal is to completely finish whatever is asked.

## Overview

This is a Laravel-based web application template.

## Tech Stack

- **Backend**: Laravel (latest stable), PHP 8.1+
- **Database**: PostgreSQL (via Laravel's Eloquent ORM)
- **Frontend**: Blade templates, Livewire, Alpine.js, Tailwind CSS
- **Testing**: Pest for testing

## Project Structure

Use Laravel's conventional directory structure:

- `app/` - Application code (Controllers, Models, Services, Actions, etc.)
  - `Actions/` - Application and domain logic encapsulated as actions
  - `Http/Controllers/` - Controllers for handling HTTP requests
  - `Http/Requests/` - Form request validation
  - `Models/` - Eloquent models
  - `Policies/` - Authorization policies
- `bootstrap/` - Application bootstraping
- `config/` - Configuration files
- `database/` - Database migrations, seeders, and factories
- `public/` - Publicly accessible directory (CSS, JS, images)
- `resources/`
  - `views/` - Blade templates and Livewire components (e.g., `resources/views/livewire`)
  - `js/components` - Alpine.js components
  - `css/` or `sass/` - CSS or SCSS files (Tailwind configuration)
- `routes/` - Route definitions (`web.php`, `api.php`)
- `storage/` - File-based storage
- `tests/` - Pest test files
- `vendor/` - Composer dependencies

## Rules

Follow these rules when building the project.

### General Rules

- Use namespaces properly and follow PSR-4 autoloading.
- Use `@extends` and `@section` in Blade for layouts.
- Use service container and dependency injection where appropriate.
- Keep controller methods thin; move complex logic into actions or services.
- Use Eloquent ORM and avoid raw SQL unless necessary.
- Implement proper request validation using Form Requests.
- Follow SOLID principles and Laravel conventions.
- Use `.env` files for environment configuration. Mirror changes in `.env.example`.
- Do not expose private credentials or environment variables directly to the frontend.
- Use `NEXT_PUBLIC_` prefix or a similar pattern only if you must expose a variable to the frontend (in this Laravel context, consider using environment variables only in backend logic or pass necessary data through Blade or Livewire props).

### Type & Code Style Rules

- Use PHP 8.1+ features (typed properties, enums, attributes) when appropriate.
- Follow PSR-12 coding standards.
- Prefer interfaces over type aliases for complex types when relevant.
- For domain-specific or complex data shapes, create value objects or DTOs in `app/DTOs` or `app/ValueObjects`.

### Frontend Rules

- Use Blade templates for rendering views.
- Integrate Livewire components to handle dynamic UI interactions and real-time updates.
- Use Alpine.js for lightweight client-side interactivity.
- Use Tailwind CSS for styling. Configure `tailwind.config.js` as needed.
- Keep Blade templates clean and minimal; extract UI elements into Blade components or Livewire components where possible.
- Use `div` or semantic HTML tags as needed. It's acceptable to use semantic tags (`section`, `article`, `header`, `footer`) when appropriate.
- Separate distinct parts of a Blade file with blank lines for readability.
- Utilize Laravel Mix or Vite for asset compilation (e.g., `npm run dev`).

### Backend Rules

- Use migrations for all schema changes. Keep them idempotent and meaningful.
- Implement factories and seeders for test and development data.
- Use Eloquent models for database interaction.
- Implement Repositories if necessary for complex query logic.
- Use Laravel's Query Builder or Eloquent relationships for complex queries and eager loading.
- Employ Laravel's built-in authentication scaffolding (e.g., Breeze, Jetstream).
- For domain logic, create `app/Actions/` or `app/Services/` classes and call them from controllers.
- Use Laravel Cashier for Stripe integration.
- Handle exceptions with Laravel's exception handler. Use custom exceptions where needed.
- Implement logging (using `Log` facade or logging channels) for debugging and monitoring.

### Auth Rules

- Use Laravel Breeze or Jetstream for scaffolding authentication.
- Utilize the `auth()` helper and middleware (`auth`, `verified`) for access control.
- Use Laravel Policies or Gates for authorization.

### Payments Rules

- Use Laravel Cashier for Stripe integration.
- Handle subscription logic, payment methods, and invoices through Cashier.
- Store Stripe keys in `.env` and never commit them to source control.
- Provide a proper migration and model for subscription management if needed.

### Performance and Security

- Cache frequently accessed data using Laravel's cache system.
- Use Laravel's CSRF protection for all forms (`@csrf` directive).
- Validate and sanitize all incoming data using Form Requests.
- Use middleware for authentication, authorization, and rate limiting when needed.
- Consider Laravel Horizon for queues and background jobs.
- Configure indexing in the database and use proper eager loading for performance optimization.

### Testing

- Use Pest for testing:
  - `vendor/bin/pest --filter {{TESTNAME}}`
- Write unit tests for Controllers, Actions, and Models.
- Write feature tests for Livewire components and integration points.
- Employ Laravel's testing helpers (e.g., `actingAs`, `assertDatabaseHas`).
- Run tests in CLI mode to ensure everything works as expected.

### Key Conventions

1. Follow Laravel's MVC architecture.
2. Define routes in `routes/web.php` or `routes/api.php` for public APIs.
3. Use Form Requests for validation.
4. Store views in `resources/views`, integrating Livewire and Alpine.js.
5. Define database relations in Eloquent models.
6. Use Laravel's built-in authentication and user management.
7. For APIs, return JSON responses using Laravel's API resources.
8. Use Laravel's event and listener system for decoupled code.
9. Utilize Blade components or Livewire components for reusable UI patterns.

---

When providing code examples or explanations, consider the synergy between Laravel, Livewire, Alpine.js, and Tailwind CSS. Emphasize how these technologies work together to create efficient, reactive, and visually appealing web applications, while adhering to Laravel and PHP best practices.

You can execute tests with the following command:

```
vendor/bin/pest --filter {{TESTNAME}}
```

Always run the tests in CLI mode to make sure everything works as expected.

---